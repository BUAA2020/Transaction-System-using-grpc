// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: basicInfoService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_basicInfoService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_basicInfoService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_basicInfoService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_basicInfoService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_basicInfoService_2eproto;
namespace myApplication {
class loginReq;
struct loginReqDefaultTypeInternal;
extern loginReqDefaultTypeInternal _loginReq_default_instance_;
class loginRsq;
struct loginRsqDefaultTypeInternal;
extern loginRsqDefaultTypeInternal _loginRsq_default_instance_;
class modifyGoodReq;
struct modifyGoodReqDefaultTypeInternal;
extern modifyGoodReqDefaultTypeInternal _modifyGoodReq_default_instance_;
class modifyGoodRsq;
struct modifyGoodRsqDefaultTypeInternal;
extern modifyGoodRsqDefaultTypeInternal _modifyGoodRsq_default_instance_;
class modifyUserReq;
struct modifyUserReqDefaultTypeInternal;
extern modifyUserReqDefaultTypeInternal _modifyUserReq_default_instance_;
class modifyUserRsq;
struct modifyUserRsqDefaultTypeInternal;
extern modifyUserRsqDefaultTypeInternal _modifyUserRsq_default_instance_;
class registerReq;
struct registerReqDefaultTypeInternal;
extern registerReqDefaultTypeInternal _registerReq_default_instance_;
class registerRsq;
struct registerRsqDefaultTypeInternal;
extern registerRsqDefaultTypeInternal _registerRsq_default_instance_;
class searchGoodReq;
struct searchGoodReqDefaultTypeInternal;
extern searchGoodReqDefaultTypeInternal _searchGoodReq_default_instance_;
class searchGoodRsq;
struct searchGoodRsqDefaultTypeInternal;
extern searchGoodRsqDefaultTypeInternal _searchGoodRsq_default_instance_;
class searchUserReq;
struct searchUserReqDefaultTypeInternal;
extern searchUserReqDefaultTypeInternal _searchUserReq_default_instance_;
class searchUserRsq;
struct searchUserRsqDefaultTypeInternal;
extern searchUserRsqDefaultTypeInternal _searchUserRsq_default_instance_;
class searchUserRsq_baggood;
struct searchUserRsq_baggoodDefaultTypeInternal;
extern searchUserRsq_baggoodDefaultTypeInternal _searchUserRsq_baggood_default_instance_;
}  // namespace myApplication
PROTOBUF_NAMESPACE_OPEN
template<> ::myApplication::loginReq* Arena::CreateMaybeMessage<::myApplication::loginReq>(Arena*);
template<> ::myApplication::loginRsq* Arena::CreateMaybeMessage<::myApplication::loginRsq>(Arena*);
template<> ::myApplication::modifyGoodReq* Arena::CreateMaybeMessage<::myApplication::modifyGoodReq>(Arena*);
template<> ::myApplication::modifyGoodRsq* Arena::CreateMaybeMessage<::myApplication::modifyGoodRsq>(Arena*);
template<> ::myApplication::modifyUserReq* Arena::CreateMaybeMessage<::myApplication::modifyUserReq>(Arena*);
template<> ::myApplication::modifyUserRsq* Arena::CreateMaybeMessage<::myApplication::modifyUserRsq>(Arena*);
template<> ::myApplication::registerReq* Arena::CreateMaybeMessage<::myApplication::registerReq>(Arena*);
template<> ::myApplication::registerRsq* Arena::CreateMaybeMessage<::myApplication::registerRsq>(Arena*);
template<> ::myApplication::searchGoodReq* Arena::CreateMaybeMessage<::myApplication::searchGoodReq>(Arena*);
template<> ::myApplication::searchGoodRsq* Arena::CreateMaybeMessage<::myApplication::searchGoodRsq>(Arena*);
template<> ::myApplication::searchUserReq* Arena::CreateMaybeMessage<::myApplication::searchUserReq>(Arena*);
template<> ::myApplication::searchUserRsq* Arena::CreateMaybeMessage<::myApplication::searchUserRsq>(Arena*);
template<> ::myApplication::searchUserRsq_baggood* Arena::CreateMaybeMessage<::myApplication::searchUserRsq_baggood>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace myApplication {

// ===================================================================

class loginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.loginReq) */ {
 public:
  inline loginReq() : loginReq(nullptr) {}
  ~loginReq() override;
  explicit constexpr loginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  loginReq(const loginReq& from);
  loginReq(loginReq&& from) noexcept
    : loginReq() {
    *this = ::std::move(from);
  }

  inline loginReq& operator=(const loginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline loginReq& operator=(loginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const loginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const loginReq* internal_default_instance() {
    return reinterpret_cast<const loginReq*>(
               &_loginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(loginReq& a, loginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(loginReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(loginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline loginReq* New() const final {
    return new loginReq();
  }

  loginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<loginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const loginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const loginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(loginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.loginReq";
  }
  protected:
  explicit loginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPassWordFieldNumber = 2,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passWord = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:myApplication.loginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class loginRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.loginRsq) */ {
 public:
  inline loginRsq() : loginRsq(nullptr) {}
  ~loginRsq() override;
  explicit constexpr loginRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  loginRsq(const loginRsq& from);
  loginRsq(loginRsq&& from) noexcept
    : loginRsq() {
    *this = ::std::move(from);
  }

  inline loginRsq& operator=(const loginRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline loginRsq& operator=(loginRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const loginRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const loginRsq* internal_default_instance() {
    return reinterpret_cast<const loginRsq*>(
               &_loginRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(loginRsq& a, loginRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(loginRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(loginRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline loginRsq* New() const final {
    return new loginRsq();
  }

  loginRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<loginRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const loginRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const loginRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(loginRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.loginRsq";
  }
  protected:
  explicit loginRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kGroupidFieldNumber = 1,
    kStatusFieldNumber = 2,
    kIdFieldNumber = 4,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 groupid = 1;
  void clear_groupid();
  ::PROTOBUF_NAMESPACE_ID::int32 groupid() const;
  void set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_groupid() const;
  void _internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 id = 4;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.loginRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 groupid_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class registerReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.registerReq) */ {
 public:
  inline registerReq() : registerReq(nullptr) {}
  ~registerReq() override;
  explicit constexpr registerReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerReq(const registerReq& from);
  registerReq(registerReq&& from) noexcept
    : registerReq() {
    *this = ::std::move(from);
  }

  inline registerReq& operator=(const registerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerReq& operator=(registerReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerReq* internal_default_instance() {
    return reinterpret_cast<const registerReq*>(
               &_registerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(registerReq& a, registerReq& b) {
    a.Swap(&b);
  }
  inline void Swap(registerReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline registerReq* New() const final {
    return new registerReq();
  }

  registerReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<registerReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const registerReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.registerReq";
  }
  protected:
  explicit registerReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPassWordFieldNumber = 2,
    kGroupidFieldNumber = 3,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passWord = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int32 groupid = 3;
  void clear_groupid();
  ::PROTOBUF_NAMESPACE_ID::int32 groupid() const;
  void set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_groupid() const;
  void _internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.registerReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::int32 groupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class registerRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.registerRsq) */ {
 public:
  inline registerRsq() : registerRsq(nullptr) {}
  ~registerRsq() override;
  explicit constexpr registerRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerRsq(const registerRsq& from);
  registerRsq(registerRsq&& from) noexcept
    : registerRsq() {
    *this = ::std::move(from);
  }

  inline registerRsq& operator=(const registerRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerRsq& operator=(registerRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerRsq* internal_default_instance() {
    return reinterpret_cast<const registerRsq*>(
               &_registerRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(registerRsq& a, registerRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(registerRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline registerRsq* New() const final {
    return new registerRsq();
  }

  registerRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<registerRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const registerRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.registerRsq";
  }
  protected:
  explicit registerRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kIdFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.registerRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class modifyUserReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.modifyUserReq) */ {
 public:
  inline modifyUserReq() : modifyUserReq(nullptr) {}
  ~modifyUserReq() override;
  explicit constexpr modifyUserReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  modifyUserReq(const modifyUserReq& from);
  modifyUserReq(modifyUserReq&& from) noexcept
    : modifyUserReq() {
    *this = ::std::move(from);
  }

  inline modifyUserReq& operator=(const modifyUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline modifyUserReq& operator=(modifyUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const modifyUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const modifyUserReq* internal_default_instance() {
    return reinterpret_cast<const modifyUserReq*>(
               &_modifyUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(modifyUserReq& a, modifyUserReq& b) {
    a.Swap(&b);
  }
  inline void Swap(modifyUserReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(modifyUserReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline modifyUserReq* New() const final {
    return new modifyUserReq();
  }

  modifyUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<modifyUserReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const modifyUserReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const modifyUserReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(modifyUserReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.modifyUserReq";
  }
  protected:
  explicit modifyUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPassWordFieldNumber = 2,
    kMoneyFieldNumber = 3,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passWord = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional int64 money = 3;
  bool has_money() const;
  private:
  bool _internal_has_money() const;
  public:
  void clear_money();
  ::PROTOBUF_NAMESPACE_ID::int64 money() const;
  void set_money(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_money() const;
  void _internal_set_money(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.modifyUserReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::int64 money_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class modifyUserRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.modifyUserRsq) */ {
 public:
  inline modifyUserRsq() : modifyUserRsq(nullptr) {}
  ~modifyUserRsq() override;
  explicit constexpr modifyUserRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  modifyUserRsq(const modifyUserRsq& from);
  modifyUserRsq(modifyUserRsq&& from) noexcept
    : modifyUserRsq() {
    *this = ::std::move(from);
  }

  inline modifyUserRsq& operator=(const modifyUserRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline modifyUserRsq& operator=(modifyUserRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const modifyUserRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const modifyUserRsq* internal_default_instance() {
    return reinterpret_cast<const modifyUserRsq*>(
               &_modifyUserRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(modifyUserRsq& a, modifyUserRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(modifyUserRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(modifyUserRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline modifyUserRsq* New() const final {
    return new modifyUserRsq();
  }

  modifyUserRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<modifyUserRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const modifyUserRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const modifyUserRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(modifyUserRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.modifyUserRsq";
  }
  protected:
  explicit modifyUserRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.modifyUserRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class searchUserReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.searchUserReq) */ {
 public:
  inline searchUserReq() : searchUserReq(nullptr) {}
  ~searchUserReq() override;
  explicit constexpr searchUserReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  searchUserReq(const searchUserReq& from);
  searchUserReq(searchUserReq&& from) noexcept
    : searchUserReq() {
    *this = ::std::move(from);
  }

  inline searchUserReq& operator=(const searchUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline searchUserReq& operator=(searchUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const searchUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const searchUserReq* internal_default_instance() {
    return reinterpret_cast<const searchUserReq*>(
               &_searchUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(searchUserReq& a, searchUserReq& b) {
    a.Swap(&b);
  }
  inline void Swap(searchUserReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(searchUserReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline searchUserReq* New() const final {
    return new searchUserReq();
  }

  searchUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<searchUserReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const searchUserReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const searchUserReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchUserReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.searchUserReq";
  }
  protected:
  explicit searchUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.searchUserReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class searchUserRsq_baggood final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.searchUserRsq.baggood) */ {
 public:
  inline searchUserRsq_baggood() : searchUserRsq_baggood(nullptr) {}
  ~searchUserRsq_baggood() override;
  explicit constexpr searchUserRsq_baggood(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  searchUserRsq_baggood(const searchUserRsq_baggood& from);
  searchUserRsq_baggood(searchUserRsq_baggood&& from) noexcept
    : searchUserRsq_baggood() {
    *this = ::std::move(from);
  }

  inline searchUserRsq_baggood& operator=(const searchUserRsq_baggood& from) {
    CopyFrom(from);
    return *this;
  }
  inline searchUserRsq_baggood& operator=(searchUserRsq_baggood&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const searchUserRsq_baggood& default_instance() {
    return *internal_default_instance();
  }
  static inline const searchUserRsq_baggood* internal_default_instance() {
    return reinterpret_cast<const searchUserRsq_baggood*>(
               &_searchUserRsq_baggood_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(searchUserRsq_baggood& a, searchUserRsq_baggood& b) {
    a.Swap(&b);
  }
  inline void Swap(searchUserRsq_baggood* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(searchUserRsq_baggood* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline searchUserRsq_baggood* New() const final {
    return new searchUserRsq_baggood();
  }

  searchUserRsq_baggood* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<searchUserRsq_baggood>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const searchUserRsq_baggood& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const searchUserRsq_baggood& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchUserRsq_baggood* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.searchUserRsq.baggood";
  }
  protected:
  explicit searchUserRsq_baggood(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodnameFieldNumber = 2,
    kGoodidFieldNumber = 1,
  };
  // string goodname = 2;
  void clear_goodname();
  const std::string& goodname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_goodname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_goodname();
  PROTOBUF_MUST_USE_RESULT std::string* release_goodname();
  void set_allocated_goodname(std::string* goodname);
  private:
  const std::string& _internal_goodname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_goodname(const std::string& value);
  std::string* _internal_mutable_goodname();
  public:

  // int64 goodid = 1;
  void clear_goodid();
  ::PROTOBUF_NAMESPACE_ID::int64 goodid() const;
  void set_goodid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_goodid() const;
  void _internal_set_goodid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.searchUserRsq.baggood)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr goodname_;
  ::PROTOBUF_NAMESPACE_ID::int64 goodid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class searchUserRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.searchUserRsq) */ {
 public:
  inline searchUserRsq() : searchUserRsq(nullptr) {}
  ~searchUserRsq() override;
  explicit constexpr searchUserRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  searchUserRsq(const searchUserRsq& from);
  searchUserRsq(searchUserRsq&& from) noexcept
    : searchUserRsq() {
    *this = ::std::move(from);
  }

  inline searchUserRsq& operator=(const searchUserRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline searchUserRsq& operator=(searchUserRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const searchUserRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const searchUserRsq* internal_default_instance() {
    return reinterpret_cast<const searchUserRsq*>(
               &_searchUserRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(searchUserRsq& a, searchUserRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(searchUserRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(searchUserRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline searchUserRsq* New() const final {
    return new searchUserRsq();
  }

  searchUserRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<searchUserRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const searchUserRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const searchUserRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchUserRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.searchUserRsq";
  }
  protected:
  explicit searchUserRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef searchUserRsq_baggood baggood;

  // accessors -------------------------------------------------------

  enum : int {
    kGoodFieldNumber = 3,
    kMessageFieldNumber = 2,
    kNameFieldNumber = 5,
    kMoneyFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // repeated .myApplication.searchUserRsq.baggood good = 3;
  int good_size() const;
  private:
  int _internal_good_size() const;
  public:
  void clear_good();
  ::myApplication::searchUserRsq_baggood* mutable_good(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::myApplication::searchUserRsq_baggood >*
      mutable_good();
  private:
  const ::myApplication::searchUserRsq_baggood& _internal_good(int index) const;
  ::myApplication::searchUserRsq_baggood* _internal_add_good();
  public:
  const ::myApplication::searchUserRsq_baggood& good(int index) const;
  ::myApplication::searchUserRsq_baggood* add_good();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::myApplication::searchUserRsq_baggood >&
      good() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 money = 4;
  void clear_money();
  ::PROTOBUF_NAMESPACE_ID::int64 money() const;
  void set_money(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_money() const;
  void _internal_set_money(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.searchUserRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::myApplication::searchUserRsq_baggood > good_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 money_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class modifyGoodReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.modifyGoodReq) */ {
 public:
  inline modifyGoodReq() : modifyGoodReq(nullptr) {}
  ~modifyGoodReq() override;
  explicit constexpr modifyGoodReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  modifyGoodReq(const modifyGoodReq& from);
  modifyGoodReq(modifyGoodReq&& from) noexcept
    : modifyGoodReq() {
    *this = ::std::move(from);
  }

  inline modifyGoodReq& operator=(const modifyGoodReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline modifyGoodReq& operator=(modifyGoodReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const modifyGoodReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const modifyGoodReq* internal_default_instance() {
    return reinterpret_cast<const modifyGoodReq*>(
               &_modifyGoodReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(modifyGoodReq& a, modifyGoodReq& b) {
    a.Swap(&b);
  }
  inline void Swap(modifyGoodReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(modifyGoodReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline modifyGoodReq* New() const final {
    return new modifyGoodReq();
  }

  modifyGoodReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<modifyGoodReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const modifyGoodReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const modifyGoodReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(modifyGoodReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.modifyGoodReq";
  }
  protected:
  explicit modifyGoodReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodNameFieldNumber = 1,
    kKindFieldNumber = 2,
    kCareerFieldNumber = 4,
    kLevelFieldNumber = 3,
    kGradeFieldNumber = 5,
    kColorFieldNumber = 6,
  };
  // string goodName = 1;
  void clear_goodname();
  const std::string& goodname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_goodname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_goodname();
  PROTOBUF_MUST_USE_RESULT std::string* release_goodname();
  void set_allocated_goodname(std::string* goodname);
  private:
  const std::string& _internal_goodname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_goodname(const std::string& value);
  std::string* _internal_mutable_goodname();
  public:

  // optional string kind = 2;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_MUST_USE_RESULT std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // optional string career = 4;
  bool has_career() const;
  private:
  bool _internal_has_career() const;
  public:
  void clear_career();
  const std::string& career() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_career(ArgT0&& arg0, ArgT... args);
  std::string* mutable_career();
  PROTOBUF_MUST_USE_RESULT std::string* release_career();
  void set_allocated_career(std::string* career);
  private:
  const std::string& _internal_career() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_career(const std::string& value);
  std::string* _internal_mutable_career();
  public:

  // optional int32 level = 3;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 grade = 5;
  bool has_grade() const;
  private:
  bool _internal_has_grade() const;
  public:
  void clear_grade();
  ::PROTOBUF_NAMESPACE_ID::int32 grade() const;
  void set_grade(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_grade() const;
  void _internal_set_grade(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 color = 6;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::int32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.modifyGoodReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr goodname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr career_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  ::PROTOBUF_NAMESPACE_ID::int32 grade_;
  ::PROTOBUF_NAMESPACE_ID::int32 color_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class modifyGoodRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.modifyGoodRsq) */ {
 public:
  inline modifyGoodRsq() : modifyGoodRsq(nullptr) {}
  ~modifyGoodRsq() override;
  explicit constexpr modifyGoodRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  modifyGoodRsq(const modifyGoodRsq& from);
  modifyGoodRsq(modifyGoodRsq&& from) noexcept
    : modifyGoodRsq() {
    *this = ::std::move(from);
  }

  inline modifyGoodRsq& operator=(const modifyGoodRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline modifyGoodRsq& operator=(modifyGoodRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const modifyGoodRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const modifyGoodRsq* internal_default_instance() {
    return reinterpret_cast<const modifyGoodRsq*>(
               &_modifyGoodRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(modifyGoodRsq& a, modifyGoodRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(modifyGoodRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(modifyGoodRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline modifyGoodRsq* New() const final {
    return new modifyGoodRsq();
  }

  modifyGoodRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<modifyGoodRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const modifyGoodRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const modifyGoodRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(modifyGoodRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.modifyGoodRsq";
  }
  protected:
  explicit modifyGoodRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kIdFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.modifyGoodRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class searchGoodReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.searchGoodReq) */ {
 public:
  inline searchGoodReq() : searchGoodReq(nullptr) {}
  ~searchGoodReq() override;
  explicit constexpr searchGoodReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  searchGoodReq(const searchGoodReq& from);
  searchGoodReq(searchGoodReq&& from) noexcept
    : searchGoodReq() {
    *this = ::std::move(from);
  }

  inline searchGoodReq& operator=(const searchGoodReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline searchGoodReq& operator=(searchGoodReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const searchGoodReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const searchGoodReq* internal_default_instance() {
    return reinterpret_cast<const searchGoodReq*>(
               &_searchGoodReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(searchGoodReq& a, searchGoodReq& b) {
    a.Swap(&b);
  }
  inline void Swap(searchGoodReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(searchGoodReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline searchGoodReq* New() const final {
    return new searchGoodReq();
  }

  searchGoodReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<searchGoodReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const searchGoodReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const searchGoodReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchGoodReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.searchGoodReq";
  }
  protected:
  explicit searchGoodReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.searchGoodReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// -------------------------------------------------------------------

class searchGoodRsq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myApplication.searchGoodRsq) */ {
 public:
  inline searchGoodRsq() : searchGoodRsq(nullptr) {}
  ~searchGoodRsq() override;
  explicit constexpr searchGoodRsq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  searchGoodRsq(const searchGoodRsq& from);
  searchGoodRsq(searchGoodRsq&& from) noexcept
    : searchGoodRsq() {
    *this = ::std::move(from);
  }

  inline searchGoodRsq& operator=(const searchGoodRsq& from) {
    CopyFrom(from);
    return *this;
  }
  inline searchGoodRsq& operator=(searchGoodRsq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const searchGoodRsq& default_instance() {
    return *internal_default_instance();
  }
  static inline const searchGoodRsq* internal_default_instance() {
    return reinterpret_cast<const searchGoodRsq*>(
               &_searchGoodRsq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(searchGoodRsq& a, searchGoodRsq& b) {
    a.Swap(&b);
  }
  inline void Swap(searchGoodRsq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(searchGoodRsq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline searchGoodRsq* New() const final {
    return new searchGoodRsq();
  }

  searchGoodRsq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<searchGoodRsq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const searchGoodRsq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const searchGoodRsq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(searchGoodRsq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "myApplication.searchGoodRsq";
  }
  protected:
  explicit searchGoodRsq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kGoodNameFieldNumber = 3,
    kKindFieldNumber = 4,
    kCareerFieldNumber = 6,
    kStatusFieldNumber = 1,
    kLevelFieldNumber = 5,
    kGradeFieldNumber = 7,
    kColorFieldNumber = 8,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string goodName = 3;
  void clear_goodname();
  const std::string& goodname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_goodname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_goodname();
  PROTOBUF_MUST_USE_RESULT std::string* release_goodname();
  void set_allocated_goodname(std::string* goodname);
  private:
  const std::string& _internal_goodname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_goodname(const std::string& value);
  std::string* _internal_mutable_goodname();
  public:

  // string kind = 4;
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_MUST_USE_RESULT std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // string career = 6;
  void clear_career();
  const std::string& career() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_career(ArgT0&& arg0, ArgT... args);
  std::string* mutable_career();
  PROTOBUF_MUST_USE_RESULT std::string* release_career();
  void set_allocated_career(std::string* career);
  private:
  const std::string& _internal_career() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_career(const std::string& value);
  std::string* _internal_mutable_career();
  public:

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 level = 5;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 grade = 7;
  void clear_grade();
  ::PROTOBUF_NAMESPACE_ID::int32 grade() const;
  void set_grade(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_grade() const;
  void _internal_set_grade(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 color = 8;
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::int32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:myApplication.searchGoodRsq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr goodname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr career_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  ::PROTOBUF_NAMESPACE_ID::int32 grade_;
  ::PROTOBUF_NAMESPACE_ID::int32 color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_basicInfoService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// loginReq

// string userName = 1;
inline void loginReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& loginReq::username() const {
  // @@protoc_insertion_point(field_get:myApplication.loginReq.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.loginReq.userName)
}
inline std::string* loginReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:myApplication.loginReq.userName)
  return _s;
}
inline const std::string& loginReq::_internal_username() const {
  return username_.Get();
}
inline void loginReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* loginReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* loginReq::release_username() {
  // @@protoc_insertion_point(field_release:myApplication.loginReq.userName)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void loginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.loginReq.userName)
}

// string passWord = 2;
inline void loginReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& loginReq::password() const {
  // @@protoc_insertion_point(field_get:myApplication.loginReq.passWord)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.loginReq.passWord)
}
inline std::string* loginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:myApplication.loginReq.passWord)
  return _s;
}
inline const std::string& loginReq::_internal_password() const {
  return password_.Get();
}
inline void loginReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* loginReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* loginReq::release_password() {
  // @@protoc_insertion_point(field_release:myApplication.loginReq.passWord)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void loginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.loginReq.passWord)
}

// -------------------------------------------------------------------

// loginRsq

// int32 groupid = 1;
inline void loginRsq::clear_groupid() {
  groupid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 loginRsq::_internal_groupid() const {
  return groupid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 loginRsq::groupid() const {
  // @@protoc_insertion_point(field_get:myApplication.loginRsq.groupid)
  return _internal_groupid();
}
inline void loginRsq::_internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  groupid_ = value;
}
inline void loginRsq::set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:myApplication.loginRsq.groupid)
}

// int32 status = 2;
inline void loginRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 loginRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 loginRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.loginRsq.status)
  return _internal_status();
}
inline void loginRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void loginRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.loginRsq.status)
}

// string message = 3;
inline void loginRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& loginRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.loginRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void loginRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.loginRsq.message)
}
inline std::string* loginRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.loginRsq.message)
  return _s;
}
inline const std::string& loginRsq::_internal_message() const {
  return message_.Get();
}
inline void loginRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* loginRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* loginRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.loginRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void loginRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.loginRsq.message)
}

// int64 id = 4;
inline void loginRsq::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 loginRsq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 loginRsq::id() const {
  // @@protoc_insertion_point(field_get:myApplication.loginRsq.id)
  return _internal_id();
}
inline void loginRsq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void loginRsq::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:myApplication.loginRsq.id)
}

// -------------------------------------------------------------------

// registerReq

// string userName = 1;
inline void registerReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& registerReq::username() const {
  // @@protoc_insertion_point(field_get:myApplication.registerReq.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void registerReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.registerReq.userName)
}
inline std::string* registerReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:myApplication.registerReq.userName)
  return _s;
}
inline const std::string& registerReq::_internal_username() const {
  return username_.Get();
}
inline void registerReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* registerReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* registerReq::release_username() {
  // @@protoc_insertion_point(field_release:myApplication.registerReq.userName)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void registerReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.registerReq.userName)
}

// string passWord = 2;
inline void registerReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& registerReq::password() const {
  // @@protoc_insertion_point(field_get:myApplication.registerReq.passWord)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void registerReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.registerReq.passWord)
}
inline std::string* registerReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:myApplication.registerReq.passWord)
  return _s;
}
inline const std::string& registerReq::_internal_password() const {
  return password_.Get();
}
inline void registerReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* registerReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* registerReq::release_password() {
  // @@protoc_insertion_point(field_release:myApplication.registerReq.passWord)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void registerReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.registerReq.passWord)
}

// int32 groupid = 3;
inline void registerReq::clear_groupid() {
  groupid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 registerReq::_internal_groupid() const {
  return groupid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 registerReq::groupid() const {
  // @@protoc_insertion_point(field_get:myApplication.registerReq.groupid)
  return _internal_groupid();
}
inline void registerReq::_internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  groupid_ = value;
}
inline void registerReq::set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:myApplication.registerReq.groupid)
}

// -------------------------------------------------------------------

// registerRsq

// int32 status = 1;
inline void registerRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 registerRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 registerRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.registerRsq.status)
  return _internal_status();
}
inline void registerRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void registerRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.registerRsq.status)
}

// string message = 2;
inline void registerRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& registerRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.registerRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void registerRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.registerRsq.message)
}
inline std::string* registerRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.registerRsq.message)
  return _s;
}
inline const std::string& registerRsq::_internal_message() const {
  return message_.Get();
}
inline void registerRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* registerRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* registerRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.registerRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void registerRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.registerRsq.message)
}

// int64 id = 3;
inline void registerRsq::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 registerRsq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 registerRsq::id() const {
  // @@protoc_insertion_point(field_get:myApplication.registerRsq.id)
  return _internal_id();
}
inline void registerRsq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void registerRsq::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:myApplication.registerRsq.id)
}

// -------------------------------------------------------------------

// modifyUserReq

// string userName = 1;
inline void modifyUserReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& modifyUserReq::username() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyUserReq.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyUserReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyUserReq.userName)
}
inline std::string* modifyUserReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyUserReq.userName)
  return _s;
}
inline const std::string& modifyUserReq::_internal_username() const {
  return username_.Get();
}
inline void modifyUserReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyUserReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyUserReq::release_username() {
  // @@protoc_insertion_point(field_release:myApplication.modifyUserReq.userName)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyUserReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyUserReq.userName)
}

// string passWord = 2;
inline void modifyUserReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& modifyUserReq::password() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyUserReq.passWord)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyUserReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyUserReq.passWord)
}
inline std::string* modifyUserReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyUserReq.passWord)
  return _s;
}
inline const std::string& modifyUserReq::_internal_password() const {
  return password_.Get();
}
inline void modifyUserReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyUserReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyUserReq::release_password() {
  // @@protoc_insertion_point(field_release:myApplication.modifyUserReq.passWord)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyUserReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyUserReq.passWord)
}

// optional int64 money = 3;
inline bool modifyUserReq::_internal_has_money() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool modifyUserReq::has_money() const {
  return _internal_has_money();
}
inline void modifyUserReq::clear_money() {
  money_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 modifyUserReq::_internal_money() const {
  return money_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 modifyUserReq::money() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyUserReq.money)
  return _internal_money();
}
inline void modifyUserReq::_internal_set_money(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  money_ = value;
}
inline void modifyUserReq::set_money(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyUserReq.money)
}

// -------------------------------------------------------------------

// modifyUserRsq

// int32 status = 1;
inline void modifyUserRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyUserRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyUserRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyUserRsq.status)
  return _internal_status();
}
inline void modifyUserRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void modifyUserRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyUserRsq.status)
}

// string message = 2;
inline void modifyUserRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& modifyUserRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyUserRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyUserRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyUserRsq.message)
}
inline std::string* modifyUserRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyUserRsq.message)
  return _s;
}
inline const std::string& modifyUserRsq::_internal_message() const {
  return message_.Get();
}
inline void modifyUserRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyUserRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyUserRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.modifyUserRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyUserRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyUserRsq.message)
}

// -------------------------------------------------------------------

// searchUserReq

// int64 id = 1;
inline void searchUserReq::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserReq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserReq::id() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserReq.id)
  return _internal_id();
}
inline void searchUserReq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void searchUserReq::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:myApplication.searchUserReq.id)
}

// -------------------------------------------------------------------

// searchUserRsq_baggood

// int64 goodid = 1;
inline void searchUserRsq_baggood::clear_goodid() {
  goodid_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserRsq_baggood::_internal_goodid() const {
  return goodid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserRsq_baggood::goodid() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.baggood.goodid)
  return _internal_goodid();
}
inline void searchUserRsq_baggood::_internal_set_goodid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  goodid_ = value;
}
inline void searchUserRsq_baggood::set_goodid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_goodid(value);
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.baggood.goodid)
}

// string goodname = 2;
inline void searchUserRsq_baggood::clear_goodname() {
  goodname_.ClearToEmpty();
}
inline const std::string& searchUserRsq_baggood::goodname() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.baggood.goodname)
  return _internal_goodname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchUserRsq_baggood::set_goodname(ArgT0&& arg0, ArgT... args) {
 
 goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.baggood.goodname)
}
inline std::string* searchUserRsq_baggood::mutable_goodname() {
  std::string* _s = _internal_mutable_goodname();
  // @@protoc_insertion_point(field_mutable:myApplication.searchUserRsq.baggood.goodname)
  return _s;
}
inline const std::string& searchUserRsq_baggood::_internal_goodname() const {
  return goodname_.Get();
}
inline void searchUserRsq_baggood::_internal_set_goodname(const std::string& value) {
  
  goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchUserRsq_baggood::_internal_mutable_goodname() {
  
  return goodname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchUserRsq_baggood::release_goodname() {
  // @@protoc_insertion_point(field_release:myApplication.searchUserRsq.baggood.goodname)
  return goodname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchUserRsq_baggood::set_allocated_goodname(std::string* goodname) {
  if (goodname != nullptr) {
    
  } else {
    
  }
  goodname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), goodname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchUserRsq.baggood.goodname)
}

// -------------------------------------------------------------------

// searchUserRsq

// int32 status = 1;
inline void searchUserRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchUserRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchUserRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.status)
  return _internal_status();
}
inline void searchUserRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void searchUserRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.status)
}

// string message = 2;
inline void searchUserRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& searchUserRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchUserRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.message)
}
inline std::string* searchUserRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.searchUserRsq.message)
  return _s;
}
inline const std::string& searchUserRsq::_internal_message() const {
  return message_.Get();
}
inline void searchUserRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchUserRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchUserRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.searchUserRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchUserRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchUserRsq.message)
}

// repeated .myApplication.searchUserRsq.baggood good = 3;
inline int searchUserRsq::_internal_good_size() const {
  return good_.size();
}
inline int searchUserRsq::good_size() const {
  return _internal_good_size();
}
inline void searchUserRsq::clear_good() {
  good_.Clear();
}
inline ::myApplication::searchUserRsq_baggood* searchUserRsq::mutable_good(int index) {
  // @@protoc_insertion_point(field_mutable:myApplication.searchUserRsq.good)
  return good_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::myApplication::searchUserRsq_baggood >*
searchUserRsq::mutable_good() {
  // @@protoc_insertion_point(field_mutable_list:myApplication.searchUserRsq.good)
  return &good_;
}
inline const ::myApplication::searchUserRsq_baggood& searchUserRsq::_internal_good(int index) const {
  return good_.Get(index);
}
inline const ::myApplication::searchUserRsq_baggood& searchUserRsq::good(int index) const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.good)
  return _internal_good(index);
}
inline ::myApplication::searchUserRsq_baggood* searchUserRsq::_internal_add_good() {
  return good_.Add();
}
inline ::myApplication::searchUserRsq_baggood* searchUserRsq::add_good() {
  ::myApplication::searchUserRsq_baggood* _add = _internal_add_good();
  // @@protoc_insertion_point(field_add:myApplication.searchUserRsq.good)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::myApplication::searchUserRsq_baggood >&
searchUserRsq::good() const {
  // @@protoc_insertion_point(field_list:myApplication.searchUserRsq.good)
  return good_;
}

// int64 money = 4;
inline void searchUserRsq::clear_money() {
  money_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserRsq::_internal_money() const {
  return money_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchUserRsq::money() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.money)
  return _internal_money();
}
inline void searchUserRsq::_internal_set_money(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  money_ = value;
}
inline void searchUserRsq::set_money(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.money)
}

// string name = 5;
inline void searchUserRsq::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& searchUserRsq::name() const {
  // @@protoc_insertion_point(field_get:myApplication.searchUserRsq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchUserRsq::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchUserRsq.name)
}
inline std::string* searchUserRsq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:myApplication.searchUserRsq.name)
  return _s;
}
inline const std::string& searchUserRsq::_internal_name() const {
  return name_.Get();
}
inline void searchUserRsq::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchUserRsq::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchUserRsq::release_name() {
  // @@protoc_insertion_point(field_release:myApplication.searchUserRsq.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchUserRsq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchUserRsq.name)
}

// -------------------------------------------------------------------

// modifyGoodReq

// string goodName = 1;
inline void modifyGoodReq::clear_goodname() {
  goodname_.ClearToEmpty();
}
inline const std::string& modifyGoodReq::goodname() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.goodName)
  return _internal_goodname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyGoodReq::set_goodname(ArgT0&& arg0, ArgT... args) {
 
 goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.goodName)
}
inline std::string* modifyGoodReq::mutable_goodname() {
  std::string* _s = _internal_mutable_goodname();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyGoodReq.goodName)
  return _s;
}
inline const std::string& modifyGoodReq::_internal_goodname() const {
  return goodname_.Get();
}
inline void modifyGoodReq::_internal_set_goodname(const std::string& value) {
  
  goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::_internal_mutable_goodname() {
  
  return goodname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::release_goodname() {
  // @@protoc_insertion_point(field_release:myApplication.modifyGoodReq.goodName)
  return goodname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyGoodReq::set_allocated_goodname(std::string* goodname) {
  if (goodname != nullptr) {
    
  } else {
    
  }
  goodname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), goodname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyGoodReq.goodName)
}

// optional string kind = 2;
inline bool modifyGoodReq::_internal_has_kind() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool modifyGoodReq::has_kind() const {
  return _internal_has_kind();
}
inline void modifyGoodReq::clear_kind() {
  kind_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& modifyGoodReq::kind() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyGoodReq::set_kind(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.kind)
}
inline std::string* modifyGoodReq::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyGoodReq.kind)
  return _s;
}
inline const std::string& modifyGoodReq::_internal_kind() const {
  return kind_.Get();
}
inline void modifyGoodReq::_internal_set_kind(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::_internal_mutable_kind() {
  _has_bits_[0] |= 0x00000001u;
  return kind_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::release_kind() {
  // @@protoc_insertion_point(field_release:myApplication.modifyGoodReq.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return kind_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyGoodReq::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  kind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyGoodReq.kind)
}

// optional int32 level = 3;
inline bool modifyGoodReq::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool modifyGoodReq::has_level() const {
  return _internal_has_level();
}
inline void modifyGoodReq::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::level() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.level)
  return _internal_level();
}
inline void modifyGoodReq::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  level_ = value;
}
inline void modifyGoodReq::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.level)
}

// optional string career = 4;
inline bool modifyGoodReq::_internal_has_career() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool modifyGoodReq::has_career() const {
  return _internal_has_career();
}
inline void modifyGoodReq::clear_career() {
  career_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& modifyGoodReq::career() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.career)
  return _internal_career();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyGoodReq::set_career(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 career_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.career)
}
inline std::string* modifyGoodReq::mutable_career() {
  std::string* _s = _internal_mutable_career();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyGoodReq.career)
  return _s;
}
inline const std::string& modifyGoodReq::_internal_career() const {
  return career_.Get();
}
inline void modifyGoodReq::_internal_set_career(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  career_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::_internal_mutable_career() {
  _has_bits_[0] |= 0x00000002u;
  return career_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyGoodReq::release_career() {
  // @@protoc_insertion_point(field_release:myApplication.modifyGoodReq.career)
  if (!_internal_has_career()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return career_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyGoodReq::set_allocated_career(std::string* career) {
  if (career != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  career_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), career,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyGoodReq.career)
}

// optional int32 grade = 5;
inline bool modifyGoodReq::_internal_has_grade() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool modifyGoodReq::has_grade() const {
  return _internal_has_grade();
}
inline void modifyGoodReq::clear_grade() {
  grade_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::_internal_grade() const {
  return grade_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::grade() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.grade)
  return _internal_grade();
}
inline void modifyGoodReq::_internal_set_grade(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  grade_ = value;
}
inline void modifyGoodReq::set_grade(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_grade(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.grade)
}

// optional int32 color = 6;
inline bool modifyGoodReq::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool modifyGoodReq::has_color() const {
  return _internal_has_color();
}
inline void modifyGoodReq::clear_color() {
  color_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodReq::color() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodReq.color)
  return _internal_color();
}
inline void modifyGoodReq::_internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  color_ = value;
}
inline void modifyGoodReq::set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodReq.color)
}

// -------------------------------------------------------------------

// modifyGoodRsq

// int32 status = 1;
inline void modifyGoodRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 modifyGoodRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodRsq.status)
  return _internal_status();
}
inline void modifyGoodRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void modifyGoodRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodRsq.status)
}

// string message = 2;
inline void modifyGoodRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& modifyGoodRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void modifyGoodRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodRsq.message)
}
inline std::string* modifyGoodRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.modifyGoodRsq.message)
  return _s;
}
inline const std::string& modifyGoodRsq::_internal_message() const {
  return message_.Get();
}
inline void modifyGoodRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* modifyGoodRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* modifyGoodRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.modifyGoodRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void modifyGoodRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.modifyGoodRsq.message)
}

// int64 id = 3;
inline void modifyGoodRsq::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 modifyGoodRsq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 modifyGoodRsq::id() const {
  // @@protoc_insertion_point(field_get:myApplication.modifyGoodRsq.id)
  return _internal_id();
}
inline void modifyGoodRsq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void modifyGoodRsq::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:myApplication.modifyGoodRsq.id)
}

// -------------------------------------------------------------------

// searchGoodReq

// int64 id = 1;
inline void searchGoodReq::clear_id() {
  id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchGoodReq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 searchGoodReq::id() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodReq.id)
  return _internal_id();
}
inline void searchGoodReq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void searchGoodReq::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:myApplication.searchGoodReq.id)
}

// -------------------------------------------------------------------

// searchGoodRsq

// int32 status = 1;
inline void searchGoodRsq::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::status() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.status)
  return _internal_status();
}
inline void searchGoodRsq::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void searchGoodRsq::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.status)
}

// string message = 2;
inline void searchGoodRsq::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& searchGoodRsq::message() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchGoodRsq::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.message)
}
inline std::string* searchGoodRsq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myApplication.searchGoodRsq.message)
  return _s;
}
inline const std::string& searchGoodRsq::_internal_message() const {
  return message_.Get();
}
inline void searchGoodRsq::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::release_message() {
  // @@protoc_insertion_point(field_release:myApplication.searchGoodRsq.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchGoodRsq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchGoodRsq.message)
}

// string goodName = 3;
inline void searchGoodRsq::clear_goodname() {
  goodname_.ClearToEmpty();
}
inline const std::string& searchGoodRsq::goodname() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.goodName)
  return _internal_goodname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchGoodRsq::set_goodname(ArgT0&& arg0, ArgT... args) {
 
 goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.goodName)
}
inline std::string* searchGoodRsq::mutable_goodname() {
  std::string* _s = _internal_mutable_goodname();
  // @@protoc_insertion_point(field_mutable:myApplication.searchGoodRsq.goodName)
  return _s;
}
inline const std::string& searchGoodRsq::_internal_goodname() const {
  return goodname_.Get();
}
inline void searchGoodRsq::_internal_set_goodname(const std::string& value) {
  
  goodname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::_internal_mutable_goodname() {
  
  return goodname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::release_goodname() {
  // @@protoc_insertion_point(field_release:myApplication.searchGoodRsq.goodName)
  return goodname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchGoodRsq::set_allocated_goodname(std::string* goodname) {
  if (goodname != nullptr) {
    
  } else {
    
  }
  goodname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), goodname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchGoodRsq.goodName)
}

// string kind = 4;
inline void searchGoodRsq::clear_kind() {
  kind_.ClearToEmpty();
}
inline const std::string& searchGoodRsq::kind() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchGoodRsq::set_kind(ArgT0&& arg0, ArgT... args) {
 
 kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.kind)
}
inline std::string* searchGoodRsq::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:myApplication.searchGoodRsq.kind)
  return _s;
}
inline const std::string& searchGoodRsq::_internal_kind() const {
  return kind_.Get();
}
inline void searchGoodRsq::_internal_set_kind(const std::string& value) {
  
  kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::_internal_mutable_kind() {
  
  return kind_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::release_kind() {
  // @@protoc_insertion_point(field_release:myApplication.searchGoodRsq.kind)
  return kind_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchGoodRsq::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    
  } else {
    
  }
  kind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchGoodRsq.kind)
}

// int32 level = 5;
inline void searchGoodRsq::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::level() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.level)
  return _internal_level();
}
inline void searchGoodRsq::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void searchGoodRsq::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.level)
}

// string career = 6;
inline void searchGoodRsq::clear_career() {
  career_.ClearToEmpty();
}
inline const std::string& searchGoodRsq::career() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.career)
  return _internal_career();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void searchGoodRsq::set_career(ArgT0&& arg0, ArgT... args) {
 
 career_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.career)
}
inline std::string* searchGoodRsq::mutable_career() {
  std::string* _s = _internal_mutable_career();
  // @@protoc_insertion_point(field_mutable:myApplication.searchGoodRsq.career)
  return _s;
}
inline const std::string& searchGoodRsq::_internal_career() const {
  return career_.Get();
}
inline void searchGoodRsq::_internal_set_career(const std::string& value) {
  
  career_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::_internal_mutable_career() {
  
  return career_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* searchGoodRsq::release_career() {
  // @@protoc_insertion_point(field_release:myApplication.searchGoodRsq.career)
  return career_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void searchGoodRsq::set_allocated_career(std::string* career) {
  if (career != nullptr) {
    
  } else {
    
  }
  career_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), career,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:myApplication.searchGoodRsq.career)
}

// int32 grade = 7;
inline void searchGoodRsq::clear_grade() {
  grade_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::_internal_grade() const {
  return grade_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::grade() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.grade)
  return _internal_grade();
}
inline void searchGoodRsq::_internal_set_grade(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  grade_ = value;
}
inline void searchGoodRsq::set_grade(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_grade(value);
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.grade)
}

// int32 color = 8;
inline void searchGoodRsq::clear_color() {
  color_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 searchGoodRsq::color() const {
  // @@protoc_insertion_point(field_get:myApplication.searchGoodRsq.color)
  return _internal_color();
}
inline void searchGoodRsq::_internal_set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  color_ = value;
}
inline void searchGoodRsq::set_color(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:myApplication.searchGoodRsq.color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace myApplication

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_basicInfoService_2eproto
